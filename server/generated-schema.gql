# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateKeyValue {
  _avg: KeyValueAvgAggregate
  _count: KeyValueCountAggregate
  _max: KeyValueMaxAggregate
  _min: KeyValueMinAggregate
  _sum: KeyValueSumAggregate
}

type AggregateOKR {
  _avg: OKRAvgAggregate
  _count: OKRCountAggregate
  _max: OKRMaxAggregate
  _min: OKRMinAggregate
  _sum: OKRSumAggregate
}

type AggregateObj {
  _avg: ObjAvgAggregate
  _count: ObjCountAggregate
  _max: ObjMaxAggregate
  _min: ObjMinAggregate
  _sum: ObjSumAggregate
}

type AggregatePost {
  _avg: PostAvgAggregate
  _count: PostCountAggregate
  _max: PostMaxAggregate
  _min: PostMinAggregate
  _sum: PostSumAggregate
}

type AggregateTimeStap {
  _avg: TimeStapAvgAggregate
  _count: TimeStapCountAggregate
  _max: TimeStapMaxAggregate
  _min: TimeStapMinAggregate
  _sum: TimeStapSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

type AggregateUserOKRs {
  _avg: UserOKRsAvgAggregate
  _count: UserOKRsCountAggregate
  _max: UserOKRsMaxAggregate
  _min: UserOKRsMinAggregate
  _sum: UserOKRsSumAggregate
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type KeyValue {
  createdAt: DateTime!
  id: Int!
  okr: OKR!
  okrId: Int!
  updatedAt: DateTime!
}

type KeyValueAvgAggregate {
  id: Float
  okrId: Float
}

type KeyValueCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  okrId: Int!
  updatedAt: Int!
}

input KeyValueCreateInput {
  createdAt: DateTime
  okr: OKRCreateNestedOneWithoutKvsInput!
  updatedAt: DateTime
}

input KeyValueCreateManyInput {
  createdAt: DateTime
  id: Int
  okrId: Int!
  updatedAt: DateTime
}

input KeyValueCreateManyOkrInput {
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
}

input KeyValueCreateManyOkrInputEnvelope {
  data: [KeyValueCreateManyOkrInput!]!
  skipDuplicates: Boolean
}

input KeyValueCreateNestedManyWithoutOkrInput {
  connect: [KeyValueWhereUniqueInput!]
  connectOrCreate: [KeyValueCreateOrConnectWithoutOkrInput!]
  create: [KeyValueCreateWithoutOkrInput!]
  createMany: KeyValueCreateManyOkrInputEnvelope
}

input KeyValueCreateOrConnectWithoutOkrInput {
  create: KeyValueCreateWithoutOkrInput!
  where: KeyValueWhereUniqueInput!
}

input KeyValueCreateWithoutOkrInput {
  createdAt: DateTime
  updatedAt: DateTime
}

type KeyValueGroupBy {
  _avg: KeyValueAvgAggregate
  _count: KeyValueCountAggregate
  _max: KeyValueMaxAggregate
  _min: KeyValueMinAggregate
  _sum: KeyValueSumAggregate
  createdAt: DateTime!
  id: Int!
  okrId: Int!
  updatedAt: DateTime!
}

input KeyValueListRelationFilter {
  every: KeyValueWhereInput
  none: KeyValueWhereInput
  some: KeyValueWhereInput
}

type KeyValueMaxAggregate {
  createdAt: DateTime
  id: Int
  okrId: Int
  updatedAt: DateTime
}

type KeyValueMinAggregate {
  createdAt: DateTime
  id: Int
  okrId: Int
  updatedAt: DateTime
}

input KeyValueOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  okrId: SortOrder
  updatedAt: SortOrder
}

enum KeyValueScalarFieldEnum {
  createdAt
  id
  okrId
  updatedAt
}

input KeyValueScalarWhereInput {
  AND: [KeyValueScalarWhereInput!]
  NOT: [KeyValueScalarWhereInput!]
  OR: [KeyValueScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  okrId: IntFilter
  updatedAt: DateTimeFilter
}

input KeyValueScalarWhereWithAggregatesInput {
  AND: [KeyValueScalarWhereWithAggregatesInput!]
  NOT: [KeyValueScalarWhereWithAggregatesInput!]
  OR: [KeyValueScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  okrId: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type KeyValueSumAggregate {
  id: Int
  okrId: Int
}

input KeyValueUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  okr: OKRUpdateOneRequiredWithoutKvsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input KeyValueUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input KeyValueUpdateManyWithWhereWithoutOkrInput {
  data: KeyValueUpdateManyMutationInput!
  where: KeyValueScalarWhereInput!
}

input KeyValueUpdateManyWithoutOkrInput {
  connect: [KeyValueWhereUniqueInput!]
  connectOrCreate: [KeyValueCreateOrConnectWithoutOkrInput!]
  create: [KeyValueCreateWithoutOkrInput!]
  createMany: KeyValueCreateManyOkrInputEnvelope
  delete: [KeyValueWhereUniqueInput!]
  deleteMany: [KeyValueScalarWhereInput!]
  disconnect: [KeyValueWhereUniqueInput!]
  set: [KeyValueWhereUniqueInput!]
  update: [KeyValueUpdateWithWhereUniqueWithoutOkrInput!]
  updateMany: [KeyValueUpdateManyWithWhereWithoutOkrInput!]
  upsert: [KeyValueUpsertWithWhereUniqueWithoutOkrInput!]
}

input KeyValueUpdateWithWhereUniqueWithoutOkrInput {
  data: KeyValueUpdateWithoutOkrInput!
  where: KeyValueWhereUniqueInput!
}

input KeyValueUpdateWithoutOkrInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input KeyValueUpsertWithWhereUniqueWithoutOkrInput {
  create: KeyValueCreateWithoutOkrInput!
  update: KeyValueUpdateWithoutOkrInput!
  where: KeyValueWhereUniqueInput!
}

input KeyValueWhereInput {
  AND: [KeyValueWhereInput!]
  NOT: [KeyValueWhereInput!]
  OR: [KeyValueWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  okr: OKRRelationFilter
  okrId: IntFilter
  updatedAt: DateTimeFilter
}

input KeyValueWhereUniqueInput {
  id: Int
}

type Mutation {
  createKeyValue(data: KeyValueCreateInput!): KeyValue!
  createManyKeyValue(data: [KeyValueCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyOKR(data: [OKRCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyObj(data: [ObjCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPost(data: [PostCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTimeStap(data: [TimeStapCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUserOKRs(data: [UserOKRsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOKR(data: OKRCreateInput!): OKR!
  createObj(data: ObjCreateInput!): Obj!
  createPost(data: PostCreateInput!): Post!
  createTimeStap(data: TimeStapCreateInput!): TimeStap!
  createUser(data: UserCreateInput!): User!
  createUserOKRs(data: UserOKRsCreateInput!): UserOKRs!
  deleteKeyValue(where: KeyValueWhereUniqueInput!): KeyValue
  deleteManyKeyValue(where: KeyValueWhereInput): AffectedRowsOutput!
  deleteManyOKR(where: OKRWhereInput): AffectedRowsOutput!
  deleteManyObj(where: ObjWhereInput): AffectedRowsOutput!
  deleteManyPost(where: PostWhereInput): AffectedRowsOutput!
  deleteManyTimeStap(where: TimeStapWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteManyUserOKRs(where: UserOKRsWhereInput): AffectedRowsOutput!
  deleteOKR(where: OKRWhereUniqueInput!): OKR
  deleteObj(where: ObjWhereUniqueInput!): Obj
  deletePost(where: PostWhereUniqueInput!): Post
  deleteTimeStap(where: TimeStapWhereUniqueInput!): TimeStap
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUserOKRs(where: UserOKRsWhereUniqueInput!): UserOKRs
  updateKeyValue(data: KeyValueUpdateInput!, where: KeyValueWhereUniqueInput!): KeyValue
  updateManyKeyValue(data: KeyValueUpdateManyMutationInput!, where: KeyValueWhereInput): AffectedRowsOutput!
  updateManyOKR(data: OKRUpdateManyMutationInput!, where: OKRWhereInput): AffectedRowsOutput!
  updateManyObj(data: ObjUpdateManyMutationInput!, where: ObjWhereInput): AffectedRowsOutput!
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): AffectedRowsOutput!
  updateManyTimeStap(data: TimeStapUpdateManyMutationInput!, where: TimeStapWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateManyUserOKRs(data: UserOKRsUpdateManyMutationInput!, where: UserOKRsWhereInput): AffectedRowsOutput!
  updateOKR(data: OKRUpdateInput!, where: OKRWhereUniqueInput!): OKR
  updateObj(data: ObjUpdateInput!, where: ObjWhereUniqueInput!): Obj
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateTimeStap(data: TimeStapUpdateInput!, where: TimeStapWhereUniqueInput!): TimeStap
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateUserOKRs(data: UserOKRsUpdateInput!, where: UserOKRsWhereUniqueInput!): UserOKRs
  upsertKeyValue(create: KeyValueCreateInput!, update: KeyValueUpdateInput!, where: KeyValueWhereUniqueInput!): KeyValue!
  upsertOKR(create: OKRCreateInput!, update: OKRUpdateInput!, where: OKRWhereUniqueInput!): OKR!
  upsertObj(create: ObjCreateInput!, update: ObjUpdateInput!, where: ObjWhereUniqueInput!): Obj!
  upsertPost(create: PostCreateInput!, update: PostUpdateInput!, where: PostWhereUniqueInput!): Post!
  upsertTimeStap(create: TimeStapCreateInput!, update: TimeStapUpdateInput!, where: TimeStapWhereUniqueInput!): TimeStap!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertUserOKRs(create: UserOKRsCreateInput!, update: UserOKRsUpdateInput!, where: UserOKRsWhereUniqueInput!): UserOKRs!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type OKR {
  UserOKRs: UserOKRs
  id: Int!
  keyValueId: Int!
  kvs(cursor: KeyValueWhereUniqueInput, distinct: [KeyValueScalarFieldEnum!], orderBy: [KeyValueOrderByInput!], skip: Int, take: Int, where: KeyValueWhereInput): [KeyValue!]!
  obj: Obj!
  objId: Int!
  squence: Int
  userOKRsId: Int
}

type OKRAvgAggregate {
  id: Float
  keyValueId: Float
  objId: Float
  squence: Float
  userOKRsId: Float
}

type OKRCountAggregate {
  _all: Int!
  id: Int!
  keyValueId: Int!
  objId: Int!
  squence: Int!
  userOKRsId: Int!
}

input OKRCreateInput {
  UserOKRs: UserOKRsCreateNestedOneWithoutOkrsInput
  keyValueId: Int!
  kvs: KeyValueCreateNestedManyWithoutOkrInput
  obj: ObjCreateNestedOneWithoutOkrInput!
  squence: Int
}

input OKRCreateManyInput {
  id: Int
  keyValueId: Int!
  objId: Int!
  squence: Int
  userOKRsId: Int
}

input OKRCreateManyUserOKRsInput {
  id: Int
  keyValueId: Int!
  objId: Int!
  squence: Int
}

input OKRCreateManyUserOKRsInputEnvelope {
  data: [OKRCreateManyUserOKRsInput!]!
  skipDuplicates: Boolean
}

input OKRCreateNestedManyWithoutUserOKRsInput {
  connect: [OKRWhereUniqueInput!]
  connectOrCreate: [OKRCreateOrConnectWithoutUserOKRsInput!]
  create: [OKRCreateWithoutUserOKRsInput!]
  createMany: OKRCreateManyUserOKRsInputEnvelope
}

input OKRCreateNestedOneWithoutKvsInput {
  connect: OKRWhereUniqueInput
  connectOrCreate: OKRCreateOrConnectWithoutKvsInput
  create: OKRCreateWithoutKvsInput
}

input OKRCreateNestedOneWithoutObjInput {
  connect: OKRWhereUniqueInput
  connectOrCreate: OKRCreateOrConnectWithoutObjInput
  create: OKRCreateWithoutObjInput
}

input OKRCreateOrConnectWithoutKvsInput {
  create: OKRCreateWithoutKvsInput!
  where: OKRWhereUniqueInput!
}

input OKRCreateOrConnectWithoutObjInput {
  create: OKRCreateWithoutObjInput!
  where: OKRWhereUniqueInput!
}

input OKRCreateOrConnectWithoutUserOKRsInput {
  create: OKRCreateWithoutUserOKRsInput!
  where: OKRWhereUniqueInput!
}

input OKRCreateWithoutKvsInput {
  UserOKRs: UserOKRsCreateNestedOneWithoutOkrsInput
  keyValueId: Int!
  obj: ObjCreateNestedOneWithoutOkrInput!
  squence: Int
}

input OKRCreateWithoutObjInput {
  UserOKRs: UserOKRsCreateNestedOneWithoutOkrsInput
  keyValueId: Int!
  kvs: KeyValueCreateNestedManyWithoutOkrInput
  squence: Int
}

input OKRCreateWithoutUserOKRsInput {
  keyValueId: Int!
  kvs: KeyValueCreateNestedManyWithoutOkrInput
  obj: ObjCreateNestedOneWithoutOkrInput!
  squence: Int
}

type OKRGroupBy {
  _avg: OKRAvgAggregate
  _count: OKRCountAggregate
  _max: OKRMaxAggregate
  _min: OKRMinAggregate
  _sum: OKRSumAggregate
  id: Int!
  keyValueId: Int!
  objId: Int!
  squence: Int
  userOKRsId: Int
}

input OKRListRelationFilter {
  every: OKRWhereInput
  none: OKRWhereInput
  some: OKRWhereInput
}

type OKRMaxAggregate {
  id: Int
  keyValueId: Int
  objId: Int
  squence: Int
  userOKRsId: Int
}

type OKRMinAggregate {
  id: Int
  keyValueId: Int
  objId: Int
  squence: Int
  userOKRsId: Int
}

input OKROrderByInput {
  id: SortOrder
  keyValueId: SortOrder
  objId: SortOrder
  squence: SortOrder
  userOKRsId: SortOrder
}

input OKRRelationFilter {
  is: OKRWhereInput
  isNot: OKRWhereInput
}

enum OKRScalarFieldEnum {
  id
  keyValueId
  objId
  squence
  userOKRsId
}

input OKRScalarWhereInput {
  AND: [OKRScalarWhereInput!]
  NOT: [OKRScalarWhereInput!]
  OR: [OKRScalarWhereInput!]
  id: IntFilter
  keyValueId: IntFilter
  objId: IntFilter
  squence: IntNullableFilter
  userOKRsId: IntNullableFilter
}

input OKRScalarWhereWithAggregatesInput {
  AND: [OKRScalarWhereWithAggregatesInput!]
  NOT: [OKRScalarWhereWithAggregatesInput!]
  OR: [OKRScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  keyValueId: IntWithAggregatesFilter
  objId: IntWithAggregatesFilter
  squence: IntNullableWithAggregatesFilter
  userOKRsId: IntNullableWithAggregatesFilter
}

type OKRSumAggregate {
  id: Int
  keyValueId: Int
  objId: Int
  squence: Int
  userOKRsId: Int
}

input OKRUpdateInput {
  UserOKRs: UserOKRsUpdateOneWithoutOkrsInput
  keyValueId: IntFieldUpdateOperationsInput
  kvs: KeyValueUpdateManyWithoutOkrInput
  obj: ObjUpdateOneRequiredWithoutOkrInput
  squence: NullableIntFieldUpdateOperationsInput
}

input OKRUpdateManyMutationInput {
  keyValueId: IntFieldUpdateOperationsInput
  squence: NullableIntFieldUpdateOperationsInput
}

input OKRUpdateManyWithWhereWithoutUserOKRsInput {
  data: OKRUpdateManyMutationInput!
  where: OKRScalarWhereInput!
}

input OKRUpdateManyWithoutUserOKRsInput {
  connect: [OKRWhereUniqueInput!]
  connectOrCreate: [OKRCreateOrConnectWithoutUserOKRsInput!]
  create: [OKRCreateWithoutUserOKRsInput!]
  createMany: OKRCreateManyUserOKRsInputEnvelope
  delete: [OKRWhereUniqueInput!]
  deleteMany: [OKRScalarWhereInput!]
  disconnect: [OKRWhereUniqueInput!]
  set: [OKRWhereUniqueInput!]
  update: [OKRUpdateWithWhereUniqueWithoutUserOKRsInput!]
  updateMany: [OKRUpdateManyWithWhereWithoutUserOKRsInput!]
  upsert: [OKRUpsertWithWhereUniqueWithoutUserOKRsInput!]
}

input OKRUpdateOneRequiredWithoutKvsInput {
  connect: OKRWhereUniqueInput
  connectOrCreate: OKRCreateOrConnectWithoutKvsInput
  create: OKRCreateWithoutKvsInput
  update: OKRUpdateWithoutKvsInput
  upsert: OKRUpsertWithoutKvsInput
}

input OKRUpdateOneWithoutObjInput {
  connect: OKRWhereUniqueInput
  connectOrCreate: OKRCreateOrConnectWithoutObjInput
  create: OKRCreateWithoutObjInput
  delete: Boolean
  disconnect: Boolean
  update: OKRUpdateWithoutObjInput
  upsert: OKRUpsertWithoutObjInput
}

input OKRUpdateWithWhereUniqueWithoutUserOKRsInput {
  data: OKRUpdateWithoutUserOKRsInput!
  where: OKRWhereUniqueInput!
}

input OKRUpdateWithoutKvsInput {
  UserOKRs: UserOKRsUpdateOneWithoutOkrsInput
  keyValueId: IntFieldUpdateOperationsInput
  obj: ObjUpdateOneRequiredWithoutOkrInput
  squence: NullableIntFieldUpdateOperationsInput
}

input OKRUpdateWithoutObjInput {
  UserOKRs: UserOKRsUpdateOneWithoutOkrsInput
  keyValueId: IntFieldUpdateOperationsInput
  kvs: KeyValueUpdateManyWithoutOkrInput
  squence: NullableIntFieldUpdateOperationsInput
}

input OKRUpdateWithoutUserOKRsInput {
  keyValueId: IntFieldUpdateOperationsInput
  kvs: KeyValueUpdateManyWithoutOkrInput
  obj: ObjUpdateOneRequiredWithoutOkrInput
  squence: NullableIntFieldUpdateOperationsInput
}

input OKRUpsertWithWhereUniqueWithoutUserOKRsInput {
  create: OKRCreateWithoutUserOKRsInput!
  update: OKRUpdateWithoutUserOKRsInput!
  where: OKRWhereUniqueInput!
}

input OKRUpsertWithoutKvsInput {
  create: OKRCreateWithoutKvsInput!
  update: OKRUpdateWithoutKvsInput!
}

input OKRUpsertWithoutObjInput {
  create: OKRCreateWithoutObjInput!
  update: OKRUpdateWithoutObjInput!
}

input OKRWhereInput {
  AND: [OKRWhereInput!]
  NOT: [OKRWhereInput!]
  OR: [OKRWhereInput!]
  UserOKRs: UserOKRsRelationFilter
  id: IntFilter
  keyValueId: IntFilter
  kvs: KeyValueListRelationFilter
  obj: ObjRelationFilter
  objId: IntFilter
  squence: IntNullableFilter
  userOKRsId: IntNullableFilter
}

input OKRWhereUniqueInput {
  id: Int
  objId: Int
}

type Obj {
  createdAt: DateTime!
  id: Int!
  okr: OKR
  updatedAt: DateTime!
}

type ObjAvgAggregate {
  id: Float
}

type ObjCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  updatedAt: Int!
}

input ObjCreateInput {
  createdAt: DateTime
  okr: OKRCreateNestedOneWithoutObjInput
  updatedAt: DateTime
}

input ObjCreateManyInput {
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
}

input ObjCreateNestedOneWithoutOkrInput {
  connect: ObjWhereUniqueInput
  connectOrCreate: ObjCreateOrConnectWithoutOkrInput
  create: ObjCreateWithoutOkrInput
}

input ObjCreateOrConnectWithoutOkrInput {
  create: ObjCreateWithoutOkrInput!
  where: ObjWhereUniqueInput!
}

input ObjCreateWithoutOkrInput {
  createdAt: DateTime
  updatedAt: DateTime
}

type ObjGroupBy {
  _avg: ObjAvgAggregate
  _count: ObjCountAggregate
  _max: ObjMaxAggregate
  _min: ObjMinAggregate
  _sum: ObjSumAggregate
  createdAt: DateTime!
  id: Int!
  updatedAt: DateTime!
}

type ObjMaxAggregate {
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
}

type ObjMinAggregate {
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
}

input ObjOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input ObjRelationFilter {
  is: ObjWhereInput
  isNot: ObjWhereInput
}

enum ObjScalarFieldEnum {
  createdAt
  id
  updatedAt
}

input ObjScalarWhereWithAggregatesInput {
  AND: [ObjScalarWhereWithAggregatesInput!]
  NOT: [ObjScalarWhereWithAggregatesInput!]
  OR: [ObjScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ObjSumAggregate {
  id: Int
}

input ObjUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  okr: OKRUpdateOneWithoutObjInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ObjUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ObjUpdateOneRequiredWithoutOkrInput {
  connect: ObjWhereUniqueInput
  connectOrCreate: ObjCreateOrConnectWithoutOkrInput
  create: ObjCreateWithoutOkrInput
  update: ObjUpdateWithoutOkrInput
  upsert: ObjUpsertWithoutOkrInput
}

input ObjUpdateWithoutOkrInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ObjUpsertWithoutOkrInput {
  create: ObjCreateWithoutOkrInput!
  update: ObjUpdateWithoutOkrInput!
}

input ObjWhereInput {
  AND: [ObjWhereInput!]
  NOT: [ObjWhereInput!]
  OR: [ObjWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  okr: OKRRelationFilter
  updatedAt: DateTimeFilter
}

input ObjWhereUniqueInput {
  id: Int
}

type Post {
  author: User
  authorId: Int
  content: String
  createdAt: DateTime!
  id: Int!
  published: Boolean!
  title: String!
  updatedAt: DateTime!
  viewCount: Int!
}

type PostAvgAggregate {
  authorId: Float
  id: Float
  viewCount: Float
}

type PostCountAggregate {
  _all: Int!
  authorId: Int!
  content: Int!
  createdAt: Int!
  id: Int!
  published: Int!
  title: Int!
  updatedAt: Int!
  viewCount: Int!
}

input PostCreateInput {
  author: UserCreateNestedOneWithoutPostsInput
  content: String
  createdAt: DateTime
  published: Boolean
  title: String!
  updatedAt: DateTime
  viewCount: Int
}

input PostCreateManyAuthorInput {
  content: String
  createdAt: DateTime
  id: Int
  published: Boolean
  title: String!
  updatedAt: DateTime
  viewCount: Int
}

input PostCreateManyAuthorInputEnvelope {
  data: [PostCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input PostCreateManyInput {
  authorId: Int
  content: String
  createdAt: DateTime
  id: Int
  published: Boolean
  title: String!
  updatedAt: DateTime
  viewCount: Int
}

input PostCreateNestedManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutAuthorInput!]
  create: [PostCreateWithoutAuthorInput!]
  createMany: PostCreateManyAuthorInputEnvelope
}

input PostCreateOrConnectWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostCreateWithoutAuthorInput {
  content: String
  createdAt: DateTime
  published: Boolean
  title: String!
  updatedAt: DateTime
  viewCount: Int
}

type PostGroupBy {
  _avg: PostAvgAggregate
  _count: PostCountAggregate
  _max: PostMaxAggregate
  _min: PostMinAggregate
  _sum: PostSumAggregate
  authorId: Int
  content: String
  createdAt: DateTime!
  id: Int!
  published: Boolean!
  title: String!
  updatedAt: DateTime!
  viewCount: Int!
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

type PostMaxAggregate {
  authorId: Int
  content: String
  createdAt: DateTime
  id: Int
  published: Boolean
  title: String
  updatedAt: DateTime
  viewCount: Int
}

type PostMinAggregate {
  authorId: Int
  content: String
  createdAt: DateTime
  id: Int
  published: Boolean
  title: String
  updatedAt: DateTime
  viewCount: Int
}

input PostOrderByInput {
  authorId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  viewCount: SortOrder
}

enum PostScalarFieldEnum {
  authorId
  content
  createdAt
  id
  published
  title
  updatedAt
  viewCount
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  authorId: IntNullableFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  published: BoolFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  viewCount: IntFilter
}

input PostScalarWhereWithAggregatesInput {
  AND: [PostScalarWhereWithAggregatesInput!]
  NOT: [PostScalarWhereWithAggregatesInput!]
  OR: [PostScalarWhereWithAggregatesInput!]
  authorId: IntNullableWithAggregatesFilter
  content: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  published: BoolWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  viewCount: IntWithAggregatesFilter
}

type PostSumAggregate {
  authorId: Int
  id: Int
  viewCount: Int
}

input PostUpdateInput {
  author: UserUpdateOneWithoutPostsInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  viewCount: IntFieldUpdateOperationsInput
}

input PostUpdateManyMutationInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  viewCount: IntFieldUpdateOperationsInput
}

input PostUpdateManyWithWhereWithoutAuthorInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutAuthorInput!]
  create: [PostCreateWithoutAuthorInput!]
  createMany: PostCreateManyAuthorInputEnvelope
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [PostUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  data: PostUpdateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithoutAuthorInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  viewCount: IntFieldUpdateOperationsInput
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  update: PostUpdateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostWhereInput {
  AND: [PostWhereInput!]
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  author: UserRelationFilter
  authorId: IntNullableFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  published: BoolFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  viewCount: IntFilter
}

input PostWhereUniqueInput {
  id: Int
}

type Query {
  aggregateKeyValue(cursor: KeyValueWhereUniqueInput, orderBy: [KeyValueOrderByInput!], skip: Int, take: Int, where: KeyValueWhereInput): AggregateKeyValue!
  aggregateOKR(cursor: OKRWhereUniqueInput, orderBy: [OKROrderByInput!], skip: Int, take: Int, where: OKRWhereInput): AggregateOKR!
  aggregateObj(cursor: ObjWhereUniqueInput, orderBy: [ObjOrderByInput!], skip: Int, take: Int, where: ObjWhereInput): AggregateObj!
  aggregatePost(cursor: PostWhereUniqueInput, orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): AggregatePost!
  aggregateTimeStap(cursor: TimeStapWhereUniqueInput, orderBy: [TimeStapOrderByInput!], skip: Int, take: Int, where: TimeStapWhereInput): AggregateTimeStap!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  aggregateUserOKRs(cursor: UserOKRsWhereUniqueInput, orderBy: [UserOKRsOrderByInput!], skip: Int, take: Int, where: UserOKRsWhereInput): AggregateUserOKRs!
  findFirstKeyValue(cursor: KeyValueWhereUniqueInput, distinct: [KeyValueScalarFieldEnum!], orderBy: [KeyValueOrderByInput!], skip: Int, take: Int, where: KeyValueWhereInput): KeyValue
  findFirstOKR(cursor: OKRWhereUniqueInput, distinct: [OKRScalarFieldEnum!], orderBy: [OKROrderByInput!], skip: Int, take: Int, where: OKRWhereInput): OKR
  findFirstObj(cursor: ObjWhereUniqueInput, distinct: [ObjScalarFieldEnum!], orderBy: [ObjOrderByInput!], skip: Int, take: Int, where: ObjWhereInput): Obj
  findFirstPost(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): Post
  findFirstTimeStap(cursor: TimeStapWhereUniqueInput, distinct: [TimeStapScalarFieldEnum!], orderBy: [TimeStapOrderByInput!], skip: Int, take: Int, where: TimeStapWhereInput): TimeStap
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOKRs(cursor: UserOKRsWhereUniqueInput, distinct: [UserOKRsScalarFieldEnum!], orderBy: [UserOKRsOrderByInput!], skip: Int, take: Int, where: UserOKRsWhereInput): UserOKRs
  findManyUserOKRs(cursor: UserOKRsWhereUniqueInput, distinct: [UserOKRsScalarFieldEnum!], orderBy: [UserOKRsOrderByInput!], skip: Int, take: Int, where: UserOKRsWhereInput): [UserOKRs!]!
  findUniqueUserOKRs(where: UserOKRsWhereUniqueInput!): UserOKRs
  groupByKeyValue(by: [KeyValueScalarFieldEnum!]!, having: KeyValueScalarWhereWithAggregatesInput, orderBy: [KeyValueOrderByInput!], skip: Int, take: Int, where: KeyValueWhereInput): [KeyValueGroupBy!]!
  groupByOKR(by: [OKRScalarFieldEnum!]!, having: OKRScalarWhereWithAggregatesInput, orderBy: [OKROrderByInput!], skip: Int, take: Int, where: OKRWhereInput): [OKRGroupBy!]!
  groupByObj(by: [ObjScalarFieldEnum!]!, having: ObjScalarWhereWithAggregatesInput, orderBy: [ObjOrderByInput!], skip: Int, take: Int, where: ObjWhereInput): [ObjGroupBy!]!
  groupByPost(by: [PostScalarFieldEnum!]!, having: PostScalarWhereWithAggregatesInput, orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): [PostGroupBy!]!
  groupByTimeStap(by: [TimeStapScalarFieldEnum!]!, having: TimeStapScalarWhereWithAggregatesInput, orderBy: [TimeStapOrderByInput!], skip: Int, take: Int, where: TimeStapWhereInput): [TimeStapGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  groupByUserOKRs(by: [UserOKRsScalarFieldEnum!]!, having: UserOKRsScalarWhereWithAggregatesInput, orderBy: [UserOKRsOrderByInput!], skip: Int, take: Int, where: UserOKRsWhereInput): [UserOKRsGroupBy!]!
  keyValue(where: KeyValueWhereUniqueInput!): KeyValue
  keyValues(cursor: KeyValueWhereUniqueInput, distinct: [KeyValueScalarFieldEnum!], orderBy: [KeyValueOrderByInput!], skip: Int, take: Int, where: KeyValueWhereInput): [KeyValue!]!
  oKR(where: OKRWhereUniqueInput!): OKR
  oKRS(cursor: OKRWhereUniqueInput, distinct: [OKRScalarFieldEnum!], orderBy: [OKROrderByInput!], skip: Int, take: Int, where: OKRWhereInput): [OKR!]!
  obj(where: ObjWhereUniqueInput!): Obj
  objs(cursor: ObjWhereUniqueInput, distinct: [ObjScalarFieldEnum!], orderBy: [ObjOrderByInput!], skip: Int, take: Int, where: ObjWhereInput): [Obj!]!
  post(where: PostWhereUniqueInput!): Post
  posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  timeStap(where: TimeStapWhereUniqueInput!): TimeStap
  timeStaps(cursor: TimeStapWhereUniqueInput, distinct: [TimeStapScalarFieldEnum!], orderBy: [TimeStapOrderByInput!], skip: Int, take: Int, where: TimeStapWhereInput): [TimeStap!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type TimeStap {
  createdAt: DateTime!
  endTime: DateTime!
  id: Int!
  startTime: DateTime!
  updatedAt: DateTime!
  userOkrs(cursor: UserOKRsWhereUniqueInput, distinct: [UserOKRsScalarFieldEnum!], orderBy: [UserOKRsOrderByInput!], skip: Int, take: Int, where: UserOKRsWhereInput): [UserOKRs!]!
}

type TimeStapAvgAggregate {
  id: Float
}

type TimeStapCountAggregate {
  _all: Int!
  createdAt: Int!
  endTime: Int!
  id: Int!
  startTime: Int!
  updatedAt: Int!
}

input TimeStapCreateInput {
  createdAt: DateTime
  endTime: DateTime!
  startTime: DateTime!
  updatedAt: DateTime
  userOkrs: UserOKRsCreateNestedManyWithoutTimeStapInput
}

input TimeStapCreateManyInput {
  createdAt: DateTime
  endTime: DateTime!
  id: Int
  startTime: DateTime!
  updatedAt: DateTime
}

input TimeStapCreateNestedOneWithoutUserOkrsInput {
  connect: TimeStapWhereUniqueInput
  connectOrCreate: TimeStapCreateOrConnectWithoutUserOkrsInput
  create: TimeStapCreateWithoutUserOkrsInput
}

input TimeStapCreateOrConnectWithoutUserOkrsInput {
  create: TimeStapCreateWithoutUserOkrsInput!
  where: TimeStapWhereUniqueInput!
}

input TimeStapCreateWithoutUserOkrsInput {
  createdAt: DateTime
  endTime: DateTime!
  startTime: DateTime!
  updatedAt: DateTime
}

type TimeStapGroupBy {
  _avg: TimeStapAvgAggregate
  _count: TimeStapCountAggregate
  _max: TimeStapMaxAggregate
  _min: TimeStapMinAggregate
  _sum: TimeStapSumAggregate
  createdAt: DateTime!
  endTime: DateTime!
  id: Int!
  startTime: DateTime!
  updatedAt: DateTime!
}

type TimeStapMaxAggregate {
  createdAt: DateTime
  endTime: DateTime
  id: Int
  startTime: DateTime
  updatedAt: DateTime
}

type TimeStapMinAggregate {
  createdAt: DateTime
  endTime: DateTime
  id: Int
  startTime: DateTime
  updatedAt: DateTime
}

input TimeStapOrderByInput {
  createdAt: SortOrder
  endTime: SortOrder
  id: SortOrder
  startTime: SortOrder
  updatedAt: SortOrder
}

input TimeStapRelationFilter {
  is: TimeStapWhereInput
  isNot: TimeStapWhereInput
}

enum TimeStapScalarFieldEnum {
  createdAt
  endTime
  id
  startTime
  updatedAt
}

input TimeStapScalarWhereWithAggregatesInput {
  AND: [TimeStapScalarWhereWithAggregatesInput!]
  NOT: [TimeStapScalarWhereWithAggregatesInput!]
  OR: [TimeStapScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  endTime: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  startTime: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type TimeStapSumAggregate {
  id: Int
}

input TimeStapUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  endTime: DateTimeFieldUpdateOperationsInput
  startTime: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userOkrs: UserOKRsUpdateManyWithoutTimeStapInput
}

input TimeStapUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  endTime: DateTimeFieldUpdateOperationsInput
  startTime: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TimeStapUpdateOneWithoutUserOkrsInput {
  connect: TimeStapWhereUniqueInput
  connectOrCreate: TimeStapCreateOrConnectWithoutUserOkrsInput
  create: TimeStapCreateWithoutUserOkrsInput
  delete: Boolean
  disconnect: Boolean
  update: TimeStapUpdateWithoutUserOkrsInput
  upsert: TimeStapUpsertWithoutUserOkrsInput
}

input TimeStapUpdateWithoutUserOkrsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  endTime: DateTimeFieldUpdateOperationsInput
  startTime: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TimeStapUpsertWithoutUserOkrsInput {
  create: TimeStapCreateWithoutUserOkrsInput!
  update: TimeStapUpdateWithoutUserOkrsInput!
}

input TimeStapWhereInput {
  AND: [TimeStapWhereInput!]
  NOT: [TimeStapWhereInput!]
  OR: [TimeStapWhereInput!]
  createdAt: DateTimeFilter
  endTime: DateTimeFilter
  id: IntFilter
  startTime: DateTimeFilter
  updatedAt: DateTimeFilter
  userOkrs: UserOKRsListRelationFilter
}

input TimeStapWhereUniqueInput {
  id: Int
}

type User {
  email: String!
  id: Int!
  name: String
  posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
}

type UserAvgAggregate {
  id: Float
}

type UserCountAggregate {
  _all: Int!
  email: Int!
  id: Int!
  name: Int!
}

input UserCreateInput {
  email: String!
  name: String
  posts: PostCreateNestedManyWithoutAuthorInput
}

input UserCreateManyInput {
  email: String!
  id: Int
  name: String
}

input UserCreateNestedOneWithoutPostsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPostsInput
  create: UserCreateWithoutPostsInput
}

input UserCreateOrConnectWithoutPostsInput {
  create: UserCreateWithoutPostsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutPostsInput {
  email: String!
  name: String
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  email: String!
  id: Int!
  name: String
}

type UserMaxAggregate {
  email: String
  id: Int
  name: String
}

type UserMinAggregate {
  email: String
  id: Int
  name: String
}

type UserOKRs {
  TimeStap: TimeStap
  createdAt: DateTime!
  id: Int!
  okrs(cursor: OKRWhereUniqueInput, distinct: [OKRScalarFieldEnum!], orderBy: [OKROrderByInput!], skip: Int, take: Int, where: OKRWhereInput): [OKR!]!
  timeStapId: Int
  updatedAt: DateTime!
}

type UserOKRsAvgAggregate {
  id: Float
  timeStapId: Float
}

type UserOKRsCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  timeStapId: Int!
  updatedAt: Int!
}

input UserOKRsCreateInput {
  TimeStap: TimeStapCreateNestedOneWithoutUserOkrsInput
  createdAt: DateTime
  okrs: OKRCreateNestedManyWithoutUserOKRsInput
  updatedAt: DateTime
}

input UserOKRsCreateManyInput {
  createdAt: DateTime
  id: Int
  timeStapId: Int
  updatedAt: DateTime
}

input UserOKRsCreateManyTimeStapInput {
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
}

input UserOKRsCreateManyTimeStapInputEnvelope {
  data: [UserOKRsCreateManyTimeStapInput!]!
  skipDuplicates: Boolean
}

input UserOKRsCreateNestedManyWithoutTimeStapInput {
  connect: [UserOKRsWhereUniqueInput!]
  connectOrCreate: [UserOKRsCreateOrConnectWithoutTimeStapInput!]
  create: [UserOKRsCreateWithoutTimeStapInput!]
  createMany: UserOKRsCreateManyTimeStapInputEnvelope
}

input UserOKRsCreateNestedOneWithoutOkrsInput {
  connect: UserOKRsWhereUniqueInput
  connectOrCreate: UserOKRsCreateOrConnectWithoutOkrsInput
  create: UserOKRsCreateWithoutOkrsInput
}

input UserOKRsCreateOrConnectWithoutOkrsInput {
  create: UserOKRsCreateWithoutOkrsInput!
  where: UserOKRsWhereUniqueInput!
}

input UserOKRsCreateOrConnectWithoutTimeStapInput {
  create: UserOKRsCreateWithoutTimeStapInput!
  where: UserOKRsWhereUniqueInput!
}

input UserOKRsCreateWithoutOkrsInput {
  TimeStap: TimeStapCreateNestedOneWithoutUserOkrsInput
  createdAt: DateTime
  updatedAt: DateTime
}

input UserOKRsCreateWithoutTimeStapInput {
  createdAt: DateTime
  okrs: OKRCreateNestedManyWithoutUserOKRsInput
  updatedAt: DateTime
}

type UserOKRsGroupBy {
  _avg: UserOKRsAvgAggregate
  _count: UserOKRsCountAggregate
  _max: UserOKRsMaxAggregate
  _min: UserOKRsMinAggregate
  _sum: UserOKRsSumAggregate
  createdAt: DateTime!
  id: Int!
  timeStapId: Int
  updatedAt: DateTime!
}

input UserOKRsListRelationFilter {
  every: UserOKRsWhereInput
  none: UserOKRsWhereInput
  some: UserOKRsWhereInput
}

type UserOKRsMaxAggregate {
  createdAt: DateTime
  id: Int
  timeStapId: Int
  updatedAt: DateTime
}

type UserOKRsMinAggregate {
  createdAt: DateTime
  id: Int
  timeStapId: Int
  updatedAt: DateTime
}

input UserOKRsOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  timeStapId: SortOrder
  updatedAt: SortOrder
}

input UserOKRsRelationFilter {
  is: UserOKRsWhereInput
  isNot: UserOKRsWhereInput
}

enum UserOKRsScalarFieldEnum {
  createdAt
  id
  timeStapId
  updatedAt
}

input UserOKRsScalarWhereInput {
  AND: [UserOKRsScalarWhereInput!]
  NOT: [UserOKRsScalarWhereInput!]
  OR: [UserOKRsScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  timeStapId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input UserOKRsScalarWhereWithAggregatesInput {
  AND: [UserOKRsScalarWhereWithAggregatesInput!]
  NOT: [UserOKRsScalarWhereWithAggregatesInput!]
  OR: [UserOKRsScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  timeStapId: IntNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type UserOKRsSumAggregate {
  id: Int
  timeStapId: Int
}

input UserOKRsUpdateInput {
  TimeStap: TimeStapUpdateOneWithoutUserOkrsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  okrs: OKRUpdateManyWithoutUserOKRsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserOKRsUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserOKRsUpdateManyWithWhereWithoutTimeStapInput {
  data: UserOKRsUpdateManyMutationInput!
  where: UserOKRsScalarWhereInput!
}

input UserOKRsUpdateManyWithoutTimeStapInput {
  connect: [UserOKRsWhereUniqueInput!]
  connectOrCreate: [UserOKRsCreateOrConnectWithoutTimeStapInput!]
  create: [UserOKRsCreateWithoutTimeStapInput!]
  createMany: UserOKRsCreateManyTimeStapInputEnvelope
  delete: [UserOKRsWhereUniqueInput!]
  deleteMany: [UserOKRsScalarWhereInput!]
  disconnect: [UserOKRsWhereUniqueInput!]
  set: [UserOKRsWhereUniqueInput!]
  update: [UserOKRsUpdateWithWhereUniqueWithoutTimeStapInput!]
  updateMany: [UserOKRsUpdateManyWithWhereWithoutTimeStapInput!]
  upsert: [UserOKRsUpsertWithWhereUniqueWithoutTimeStapInput!]
}

input UserOKRsUpdateOneWithoutOkrsInput {
  connect: UserOKRsWhereUniqueInput
  connectOrCreate: UserOKRsCreateOrConnectWithoutOkrsInput
  create: UserOKRsCreateWithoutOkrsInput
  delete: Boolean
  disconnect: Boolean
  update: UserOKRsUpdateWithoutOkrsInput
  upsert: UserOKRsUpsertWithoutOkrsInput
}

input UserOKRsUpdateWithWhereUniqueWithoutTimeStapInput {
  data: UserOKRsUpdateWithoutTimeStapInput!
  where: UserOKRsWhereUniqueInput!
}

input UserOKRsUpdateWithoutOkrsInput {
  TimeStap: TimeStapUpdateOneWithoutUserOkrsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserOKRsUpdateWithoutTimeStapInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  okrs: OKRUpdateManyWithoutUserOKRsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserOKRsUpsertWithWhereUniqueWithoutTimeStapInput {
  create: UserOKRsCreateWithoutTimeStapInput!
  update: UserOKRsUpdateWithoutTimeStapInput!
  where: UserOKRsWhereUniqueInput!
}

input UserOKRsUpsertWithoutOkrsInput {
  create: UserOKRsCreateWithoutOkrsInput!
  update: UserOKRsUpdateWithoutOkrsInput!
}

input UserOKRsWhereInput {
  AND: [UserOKRsWhereInput!]
  NOT: [UserOKRsWhereInput!]
  OR: [UserOKRsWhereInput!]
  TimeStap: TimeStapRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  okrs: OKRListRelationFilter
  timeStapId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input UserOKRsWhereUniqueInput {
  id: Int
}

input UserOrderByInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  email
  id
  name
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  email: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
}

input UserUpdateInput {
  email: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorInput
}

input UserUpdateManyMutationInput {
  email: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
}

input UserUpdateOneWithoutPostsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPostsInput
  create: UserCreateWithoutPostsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutPostsInput
  upsert: UserUpsertWithoutPostsInput
}

input UserUpdateWithoutPostsInput {
  email: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
}

input UserUpsertWithoutPostsInput {
  create: UserCreateWithoutPostsInput!
  update: UserUpdateWithoutPostsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  email: StringFilter
  id: IntFilter
  name: StringNullableFilter
  posts: PostListRelationFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
